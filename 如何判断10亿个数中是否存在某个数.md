假设有这样一个需求：在10亿个不重复整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存 在Java中，int占4字节，1字节=8位（1 byte = 8 bit） 如果每个数字用int存储，那就是10亿个int，因而占用的空间约为 (1000000000*4/1024/1024/1024)≈3.8 G 如果按位存储就不一样了，10亿个数就是10亿位，占用空间约为 (1000000000/8/1024/1024/1024)≈0.12 G



那么，问题来了，如何表示一个数呢？ 刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制 这样我们可以很容易表示{1,2,4,6}这几个数：



![](https://cdn.nlark.com/yuque/0/2024/png/26411187/1711893479619-d4b6d6d0-6ad6-4e50-a1fa-3a1cd2d1aba6.png)



计算机内存分配的最小单位是字节，也就是8位，那如果要表示{12,13,15}怎么办呢？ 当然是在另一个8位上表示了

![](https://cdn.nlark.com/yuque/0/2024/png/26411187/1711893857871-d8ed90d3-b0d8-42ad-8228-2a2c2f5f45fd.png)



1个int占32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32] 即可存储，其中N表示要存储的这些数中的最大值，于是乎： tmp[0]：可以表示0~31，tmp[1]：可以表示32~63，tmp[2]：可以表示64~95 。。。 如此一来，给定任意整数M，那么M/32就得到下标，M%32就知道它在此下标的哪个位置



### 如何查找
每一位代表一个数字，1表示有（或者说存在），0表示无（或者说不存在）。那么判断一个数存不存在就是判断该数所在的位是0还是1 假设，我们想知道98731在不在，

+ 定位98731这个数应该在tmp数组的哪个数字上， 98731 / 32, 算出数组下标3085；
+ 然后98731 % 32 = 11
+ tmp[3085] & (1 << 11), 若为1，表示存在，0表示不存在







